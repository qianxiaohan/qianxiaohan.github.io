<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"qianxiaohan.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"mac"},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="16.1 string类 string实际上是模板具体化basic_string&lt;char&gt;的一个typedef，同时省略了与内存管理相关的参数。	p655 这里主要说明3为string类其中的3个构造函数：	p656  template&lt;class Iter&gt; string(Iter begin, Iter end)，将string初始化为区间[begin, end)内">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ Primer Plus第16章学习笔记">
<meta property="og:url" content="http://qianxiaohan.github.io/2024/08/08/%E7%AC%AC16%E7%AB%A0string%E7%B1%BB%E5%92%8C%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E7%B1%BB/index.html">
<meta property="og:site_name" content="Lyx&#39;s Blog">
<meta property="og:description" content="16.1 string类 string实际上是模板具体化basic_string&lt;char&gt;的一个typedef，同时省略了与内存管理相关的参数。	p655 这里主要说明3为string类其中的3个构造函数：	p656  template&lt;class Iter&gt; string(Iter begin, Iter end)，将string初始化为区间[begin, end)内">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-08-08T14:46:47.425Z">
<meta property="article:modified_time" content="2024-08-08T14:52:07.071Z">
<meta property="article:author" content="Lyx">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://qianxiaohan.github.io/2024/08/08/%E7%AC%AC16%E7%AB%A0string%E7%B1%BB%E5%92%8C%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E7%B1%BB/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://qianxiaohan.github.io/2024/08/08/%E7%AC%AC16%E7%AB%A0string%E7%B1%BB%E5%92%8C%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E7%B1%BB/","path":"2024/08/08/第16章string类和标准模板类/","title":"C++ Primer Plus第16章学习笔记"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>C++ Primer Plus第16章学习笔记 | Lyx's Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Lyx's Blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#161-string%E7%B1%BB"><span class="nav-number">1.</span> <span class="nav-text"> 16.1 string类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#162-c%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E6%A8%A1%E6%9D%BF%E7%B1%BB"><span class="nav-number">2.</span> <span class="nav-text"> 16.2 C++智能指针模板类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">2.1.</span> <span class="nav-text"> 智能指针注意事项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#unique_ptr%E4%B8%BA%E4%BD%95%E4%BC%98%E4%BA%8Eauto_ptr"><span class="nav-number">2.2.</span> <span class="nav-text"> unique_ptr为何优于auto_ptr？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E9%80%89%E6%8B%A9"><span class="nav-number">2.3.</span> <span class="nav-text"> 智能指针的选择</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#163-%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93"><span class="nav-number">3.</span> <span class="nav-text"> 16.3 标准模板库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#164-%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B"><span class="nav-number">4.</span> <span class="nav-text"> 16.4 泛型编程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#165-%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1"><span class="nav-number">5.</span> <span class="nav-text"> 16.5 函数对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#166-%E7%AE%97%E6%B3%95"><span class="nav-number">6.</span> <span class="nav-text"> 16.6 算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#167-%E5%85%B6%E4%BB%96%E5%BA%93"><span class="nav-number">7.</span> <span class="nav-text"> 16.7 其他库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#169-%E5%A4%8D%E4%B9%A0%E9%A2%98"><span class="nav-number">8.</span> <span class="nav-text"> 16.9 复习题</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Lyx</p>
  <div class="site-description" itemprop="description">记录一些在学习过程中遇到的问题，包括C/C++、STM32、RTOS等等</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">22</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://qianxiaohan.github.io/2024/08/08/%E7%AC%AC16%E7%AB%A0string%E7%B1%BB%E5%92%8C%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lyx">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lyx's Blog">
      <meta itemprop="description" content="记录一些在学习过程中遇到的问题，包括C/C++、STM32、RTOS等等">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="C++ Primer Plus第16章学习笔记 | Lyx's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++ Primer Plus第16章学习笔记
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-08-08 22:46:47 / 修改时间：22:52:07" itemprop="dateCreated datePublished" datetime="2024-08-08T22:46:47+08:00">2024-08-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h3 id="161-string类"><a class="markdownIt-Anchor" href="#161-string类"></a> 16.1 string类</h3>
<p>string实际上是模板具体化basic_string&lt;char&gt;的一个typedef，同时省略了与内存管理相关的参数。	<mark>p655</mark></p>
<p>这里主要说明3为string类其中的3个构造函数：	<mark>p656</mark></p>
<ul>
<li><code>template&lt;class Iter&gt; string(Iter begin, Iter end)</code>，将string初始化为区间[begin, end)内的字符，begin、end是两个地址。</li>
<li><code>string(string &amp;&amp; str) noexcept</code>，移动构造函数，类似于复制构造函数，导致新创建的string为str的副本，但与复制构造函数不同的是，它不保证将str视为const。</li>
<li>使用初始化列表来初始化string对象：<code>string(initalizer_list&lt;char&gt; il</code>，即可以使用<code>string str = &#123;'H', 'E', 'L', 'L', 'O'&#125;;</code>这样的方式进行初始化。</li>
</ul>
<span id="more"></span>
<p>C++中可用的输入方式： <mark>p659</mark></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对于C-风格字符串，有3种方式：</span></span><br><span class="line"><span class="type">char</span> info[<span class="number">100</span>];</span><br><span class="line">cin &gt;&gt; info;			<span class="comment">//读取一个单词</span></span><br><span class="line">cin.<span class="built_in">getline</span>(info, <span class="number">100</span>);	<span class="comment">//读取一行，丢弃&#x27;\n&#x27;</span></span><br><span class="line">cin.<span class="built_in">get</span>(info, <span class="number">100</span>);		<span class="comment">//读取一行，把到&#x27;\n&#x27;留在队列中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对于string对象，有两种方式：</span></span><br><span class="line">string stuff;</span><br><span class="line">cin &gt;&gt; stuff;			<span class="comment">//读取一个单词</span></span><br><span class="line"><span class="built_in">getline</span>(cin, stuff);	<span class="comment">//读取一行，读取到&#x27;\n&#x27;将其丢弃</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//两个版本的getline()都有一个可选参数，用于指定使用哪个字符来确定输入的边界</span></span><br><span class="line">cin.<span class="built_in">getline</span>(info, <span class="number">100</span>, <span class="string">&#x27;:&#x27;</span>);	<span class="comment">// &#x27;:&#x27;作为结束符，并将其丢弃</span></span><br><span class="line"><span class="built_in">getline</span>(stuff, <span class="string">&#x27;:&#x27;</span>);			<span class="comment">// &#x27;:&#x27;作为结束符，并将其丢弃</span></span><br></pre></td></tr></table></figure>
<p>两个版本的<code>getline()</code>的区别在于，<strong>string类版本的将自动调整目标string对象的大小</strong>，使之能够刚好存储输入的字符。</p>
<h3 id="162-c智能指针模板类"><a class="markdownIt-Anchor" href="#162-c智能指针模板类"></a> 16.2 C++智能指针模板类</h3>
<p>智能指针是行为类似于指针的类对象，平常的动态内存分配，必须要将内存在合适的时候释放，否则会造成内存泄露。类对象在过期的时候，会自动调用析构函数，释放其内存。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">remodel</span><span class="params">(std::string &amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string * ps = <span class="keyword">new</span> std::<span class="built_in">string</span>(str);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">weird_thing</span>())</span><br><span class="line">    	<span class="keyword">throw</span> <span class="built_in">exception</span>();</span><br><span class="line">    str = *ps;</span><br><span class="line">    <span class="keyword">delete</span> ps;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从以上代码看出，当抛出异常时，后面的delete语句不会执行，对应的内存不会释放，因此会造成内存泄露。</p>
<p>智能指针模板有<code>auto_ptr</code>、<code>unique_ptr</code>、<code>shared_ptr</code>，其中<code>auto_ptr</code>在C++11中已经被摈弃。举个例子</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span>	<span class="comment">//所需要的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">auto_ptr&lt;<span class="type">double</span>&gt; <span class="title">ap</span><span class="params">(<span class="keyword">new</span> <span class="type">double</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//ap在对象失效时会自动调用析构函数中的delete</span></span><br><span class="line">    <span class="comment">//delete ap;	不再需要这条语句</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="智能指针注意事项"><a class="markdownIt-Anchor" href="#智能指针注意事项"></a> 智能指针注意事项</h4>
<p>两个指针指向同一个string对象时，程序有可能释放对应的内存两次，这是不允许的。为了避免这种问题，可以</p>
<ul>
<li>定义赋值运算符，执行深拷贝，这样两个指针指向了两个不同的对象</li>
<li>建立所有权(ownership)概念，一个智能指针只能指向一个对象，可以使用赋值的方式转让所有权，<code>auto_ptr</code>和<code>unique_ptr</code>就是采用这一策略</li>
<li>创建更智能的指针，追踪有多少个智能指针指向同一对象，这种称为引用计数(reference counting)。例如，智能指针赋值时，计数+1，指针过期时，计数-1，当计数为0才调用delete，<code>shared_ptr</code>采用这一策略</li>
</ul>
<h4 id="unique_ptr为何优于auto_ptr"><a class="markdownIt-Anchor" href="#unique_ptr为何优于auto_ptr"></a> unique_ptr为何优于auto_ptr？</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">auto_ptr&lt;string&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;auto&quot;</span>))</span></span>;</span><br><span class="line">auto_ptr&lt;string&gt; p2;</span><br><span class="line">p2 = p1;	<span class="comment">//将p1的所有权(ownership)传递给p2，因此后面再使用p1，会在运行时报错</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p3</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;uniqe&quot;</span>))</span></span>;</span><br><span class="line">unique_ptr&lt;string&gt; p4;</span><br><span class="line">p4 = p3;	<span class="comment">//将p3的所有权(ownership)传递给p4，因此后面再使用p4，会在编译时报错</span></span><br></pre></td></tr></table></figure>
<p>在编译时出错比在程序运行时出错更好，因此<code>unique_ptr</code>安全性更高。相比<code>auto_ptr</code>，<code>unique_ptr</code>还有另一个优点。模板<code>auto_ptr</code>使用delete，<code>unique_ptr</code>有delete和delete[]两种版本。	<mark>p673</mark></p>
<p>注意：<code>unique_ptr</code>在使用new或new[]分配内存时可用。<code>share_ptr</code>、<code>auto_ptr</code>在使用new分配内存时可用。</p>
<h4 id="智能指针的选择"><a class="markdownIt-Anchor" href="#智能指针的选择"></a> 智能指针的选择</h4>
<ul>
<li>程序要使用多个指向同一个对象的指针，选择<code>shared_ptr</code>   <mark>p673</mark></li>
<li>程序不需要多个指向同一个对象的指针，选择<code>unique_ptr</code></li>
</ul>
<p>举个例子</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;string&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;shared&quot;</span>))</span></span>;</span><br><span class="line">shared_ptr&lt;string&gt; p2;</span><br><span class="line">shared_ptr&lt;string&gt; p3;</span><br><span class="line">p3 = p2;	<span class="comment">//计数 + 1</span></span><br><span class="line">p3 = p1;	<span class="comment">//计数 + 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当智能指针失效时，计数 - 1，直到减为0，才调用delete</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p4</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;unique&quot;</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//p4不用赋值给其他指针对象，因此选择unique_ptr</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="163-标准模板库"><a class="markdownIt-Anchor" href="#163-标准模板库"></a> 16.3 标准模板库</h3>
<ul>
<li>
<p>STL(Standard Template Library)就是标准模板库，STL提供了一组表示容器、迭代器、函数对象和算法的模板。</p>
<ul>
<li>容器(Container)：与数组类似，可存储若干个值。STL容器存储的值的类型相同。</li>
<li>算法(Algorithms)：完成特定任务的方法，如对数组进行排序或在链表中查找特定值</li>
<li>迭代器(Iterators)：能够遍历容器的对象，与能够遍历数组的指针类似，是广义指针</li>
<li>函数对象(Function objects)：类似于函数的对象，可以是类对象或函数指针(包含函数名，因为函数名被用作指针)</li>
</ul>
</li>
<li>
<p>STL使得能够构造各种容器(包括数组、队列和链表)和执行各种操作(包括搜索、排序和随机排列)。</p>
</li>
<li>
<p>与 string 类相似，各种 STL容器模板都接受一个可选的模板参数，该参数指定使用哪个分配器对象来管理内存如果省略该模板参数的值，则容器模板将默认使用 allocator&lt;T&gt;类。这个类使用 new和 delete。</p>
</li>
</ul>
<p>例如，vector模板的开头与下面类似：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Allocator</span> = allocator&lt;T&gt; &gt;</span><br><span class="line">    <span class="keyword">class</span> vector&#123; ... &#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>所有的STL容器都提供了一些基本方法：
<ul>
<li>size()：返回容器中元素个数</li>
<li>swap()：交换两个容器的内容</li>
<li>begin()：返回一个指向容器第一个元素的迭代器</li>
<li>end()：返回一个表示超过容器尾部的迭代器</li>
</ul>
</li>
</ul>
<p>基于范围的for循环：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#1</span></span><br><span class="line"><span class="type">double</span> prices[<span class="number">5</span>] = &#123;<span class="number">4.99</span>, <span class="number">10.99</span>, <span class="number">6.87</span>, <span class="number">7.99</span>, <span class="number">8.49</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">double</span> x : prices)</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//#2，books类型vector&lt;Review&gt;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> x : books)</span><br><span class="line">    <span class="built_in">ShowReview</span>(x);</span><br></pre></td></tr></table></figure>
<h3 id="164-泛型编程"><a class="markdownIt-Anchor" href="#164-泛型编程"></a> 16.4 泛型编程</h3>
<blockquote>
<p>STL是一种泛型编程(generic programming)。面向对象编程关注的是编程的数据方面，而泛型编程关注的是算法。它们之间的共同点是抽象和创建可重用代码，但它们的理念绝然不同。</p>
<p>泛型编程旨在编写独立于数据类型的代码。在 C++中，完成通用程序的工具是模板。当然，模板使得能够按泛型定义函数或类，而 STL,通过通用算法更进了一步。模板让这一切成为可能，但必须对元素进行仔细地设计。为了解模板和设计是如何协同工作的，来看一看需要迭代器的原因。  <mark>p685</mark></p>
</blockquote>
<p>模板使得算法不依赖于存储的数据类型，而迭代器使算法不依赖于使用的容器类型，它们都是STL通用方法的重要组成部分。</p>
<p><code>scores.begin()</code>：返回容器的开启位置的迭代器，<code>scores.end()</code>：返回容器超尾(pass-the-end)位置的迭代器。超尾就是容器最后一个元素的下一个位置。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用迭代器的for循环#1</span></span><br><span class="line">vector&lt;<span class="type">double</span>&gt;::iterator pr;	<span class="comment">//声明pr为vector&lt;double&gt;类型的迭代器</span></span><br><span class="line"><span class="keyword">for</span>(pr = scores.<span class="built_in">begin</span>(); pr != scores.<span class="built_in">end</span>(); pr++)</span><br><span class="line">    cout &lt;&lt; *pr &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用迭代器的for循环#2</span></span><br><span class="line">list&lt;<span class="type">double</span>&gt;::iterator pr;	<span class="comment">//声明pr为list&lt;double&gt;类型的迭代器</span></span><br><span class="line"><span class="keyword">for</span>(pr = scores.<span class="built_in">begin</span>(); pr != scores.<span class="built_in">end</span>(); pr++)</span><br><span class="line">    cout &lt;&lt; *pr &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>实际上，作为一种编程风格，最好避免直接使用迭代器，而应尽可能使用STL函数(如forcach)也可使用 C++11 新增的基于范围的for循环：<code>for(auto x : scores) cout &lt;&lt; x &lt;&lt; endl;</code>	<mark>p688</mark></p>
<p>不同的算法对迭代器的要求不同，STL定义了5种迭代器：  <mark>p688</mark></p>
<ul>
<li>输入迭代器(Input Iterators)，来自容器的信息视为输入</li>
<li>输出迭代器(Output Iterators)，将信息从程序传输给容器的迭代器</li>
<li>正向迭代器(Forward Iterators)，具有输入、输出迭代器的全部功能，只使用++运算符来遍历容器</li>
<li>双向迭代器(Bidirectional Iterators)，具有正向迭代器的所有特性，同时支持两种(前缀和后缀)递减运算符</li>
<li>随机访问迭代器( Random Access Iterators)，有些算法(如标准排序和二分检索)要求能够直接跳到容器中的任何一个元素，这叫做随机访问。随机访问迭代器具有双向迭代器的所有特性，同时添加了支持随机访问的操作(如指针增加运算a+n)</li>
</ul>
<p>主要的迭代器功能：</p>
<table>
<thead>
<tr>
<th style="text-align:center">迭代器功能</th>
<th style="text-align:center">输入</th>
<th style="text-align:center">输出</th>
<th style="text-align:center">正向</th>
<th style="text-align:center">双向</th>
<th style="text-align:center">随机访问</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">解除引用读取</td>
<td style="text-align:center">有</td>
<td style="text-align:center">无</td>
<td style="text-align:center">有</td>
<td style="text-align:center">有</td>
<td style="text-align:center">有</td>
</tr>
<tr>
<td style="text-align:center">解除引用写入</td>
<td style="text-align:center">无</td>
<td style="text-align:center">有</td>
<td style="text-align:center">有</td>
<td style="text-align:center">有</td>
<td style="text-align:center">有</td>
</tr>
<tr>
<td style="text-align:center">固定和可重复排序</td>
<td style="text-align:center">无</td>
<td style="text-align:center">无</td>
<td style="text-align:center">有</td>
<td style="text-align:center">有</td>
<td style="text-align:center">有</td>
</tr>
<tr>
<td style="text-align:center"><ins>i    i</ins></td>
<td style="text-align:center">有</td>
<td style="text-align:center">有</td>
<td style="text-align:center">有</td>
<td style="text-align:center">有</td>
<td style="text-align:center">有</td>
</tr>
<tr>
<td style="text-align:center">–i    i–</td>
<td style="text-align:center">无</td>
<td style="text-align:center">无</td>
<td style="text-align:center">无</td>
<td style="text-align:center">有</td>
<td style="text-align:center">有</td>
</tr>
<tr>
<td style="text-align:center">i[n]</td>
<td style="text-align:center">无</td>
<td style="text-align:center">无</td>
<td style="text-align:center">无</td>
<td style="text-align:center">无</td>
<td style="text-align:center">有</td>
</tr>
<tr>
<td style="text-align:center">i + n</td>
<td style="text-align:center">无</td>
<td style="text-align:center">无</td>
<td style="text-align:center">无</td>
<td style="text-align:center">无</td>
<td style="text-align:center">有</td>
</tr>
<tr>
<td style="text-align:center">i - n</td>
<td style="text-align:center">无</td>
<td style="text-align:center">无</td>
<td style="text-align:center">无</td>
<td style="text-align:center">无</td>
<td style="text-align:center">有</td>
</tr>
<tr>
<td style="text-align:center">i += n</td>
<td style="text-align:center">无</td>
<td style="text-align:center">无</td>
<td style="text-align:center">无</td>
<td style="text-align:center">无</td>
<td style="text-align:center">有</td>
</tr>
<tr>
<td style="text-align:center">i -= n</td>
<td style="text-align:center">无</td>
<td style="text-align:center">无</td>
<td style="text-align:center">无</td>
<td style="text-align:center">无</td>
<td style="text-align:center">有</td>
</tr>
</tbody>
</table>
<p>**迭代器的类型并不是确定的，不同的容器，使用的迭代器可能不同。**每个容器类都定义了一个类级typedef名称：iterator。例如，vector&lt;int&gt;类的迭代器类型为<code>vector&lt;int&gt; :: interator</code>，矢量迭代器是随机访问迭代器；list&lt;int&gt;类的迭代器类型为<code>list&lt;int&gt;:: iterator</code>，它使用双向迭代器。 <mark>p690</mark></p>
<p>可以将指针用作迭代器，由于指针是迭代器，而算法是基于迭代器的，==这使得可将STL算法用于常规数组。==例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 使用STL sort()函数对容器的数据进行排序 */</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SIZE = <span class="number">100</span>;</span><br><span class="line"><span class="type">double</span> Receipts[SIZE];</span><br><span class="line"><span class="built_in">sort</span>(Receipts, Receipts + SIZE);	<span class="comment">//使用STL sort()函数进行排序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用STL copy()函数将数据从一个容器复制到另一个容器 */</span></span><br><span class="line"><span class="type">int</span> casts[<span class="number">5</span>] = &#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">4</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; dice[<span class="number">5</span>];</span><br><span class="line"><span class="built_in">copy</span>(casts, casts + <span class="number">5</span>, dice.<span class="built_in">begin</span>());	<span class="comment">//STL copy()函数，第3个参数是输出迭代器</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><strong>其他有用的迭代器：</strong> <mark>p692</mark></p>
<ul>
<li>
<p><code>ostream_iterator</code>，输出迭代器</p>
</li>
<li>
<p><code>istream_iterator</code>，输入流迭代器</p>
</li>
<li>
<p><code>reverse_iterator</code>，反向迭代器。使用反向迭代器可以反向打印容器的内容</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; A = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="function">ostream_iterator&lt;<span class="type">int</span>&gt; <span class="title">out_iter</span><span class="params">(cout, <span class="string">&quot; &quot;</span>)</span></span>;	<span class="comment">//输出流迭代器</span></span><br><span class="line"><span class="comment">//rbegin()和end()返回相同的值(超尾)，但类型不同</span></span><br><span class="line"><span class="built_in">copy</span>(A.<span class="built_in">rbegin</span>(), A.<span class="built_in">rend</span>(), out_iter);	<span class="comment">//显示反向的序列：5 4 3 2 1</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>三种插入迭代器，插入将添加新的元素，而不会覆盖已有的数并使用自动内存分配来确保能够容纳新的信息。copy()不能自动调整目标容器的长度。</p>
<ul>
<li><code>back_insert_iterator</code>，将元素插入到容器尾部</li>
<li><code>front_insert_iterator</code>，将元素插入到容器的前端</li>
<li><code>insert_iterator</code>，将元素插入到<code>insert_iterator</code>构造函数的参数指定位置的前面</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>C++11容器种类：</strong> <mark>p695</mark></p>
<ul>
<li>以前的11个容器类型：双端队列deque、双向链表list、队列queue、prioity_queue、stack、vector、map、multimap、set、multiset、biset</li>
<li>C++11新增：单链表forward_list、unordered_map、unordered_multimap、unordered_set、unordered_multiset</li>
</ul>
</li>
<li>
<p>复制构造和复制赋值以及移动构造和移动赋值之间的差别在于，**复制操作保留源对象，而移动操作可修改源对象，还可能转让所有权，而不做任何复制。**如果源对象是临时的，移动操作的效率将高于常规复制。 <mark>p696</mark></p>
</li>
<li>
<p>模板类array是C++11提出来的，它不是STL容器，其长度是固定的。可将很多标准STL算法用于array对象，如copy()和for_each()。 <mark>p701</mark></p>
</li>
<li>
<p>**关联容器(associative container)**将值与键关联在一起，并使用键来查找值。STL提供了4种关联容器：set、multiset、map、multimap。 <mark>p702</mark></p>
<ul>
<li>**set的值类型与键的类型相同，键(key)是唯一的，不能存储多个相同的值(value)，**语法：<code>set&lt;string, less&lt;sring&gt; &gt; A;</code>第一个模板参数表示集合A中存储的值类型为string，第二个模板参数表示按照从小到大的顺序排列，默认情况下将使用<code>less&lt;&gt;</code>。 <mark>p702</mark></li>
<li>mulimap，<strong>与set相似，也是可反转、经过排序的关联容器，但键和值的类型不同，且同一个键可能与多个值关联</strong>。语法：<code>multimap&lt;int, string&gt; codes;</code>其中键的类型为int，存储的值类型为string。第3个模板参数是可选的，指出用于对键进行排序的比较函数或对象。默认情况下，使用模板<code>less&lt;&gt;</code>。</li>
</ul>
</li>
<li>
<p>无序关联容器(Unordered Associative Containers)，与关联容器一样，无序关联容器也将值与键关联起来，并使用键来查找值。但底层的差别在于，**关联容器是基于树结构的，而无序关联容器是基于数据结构哈希表的，这旨在提高添加和删除元素的速度以及提高查找算法的效率。**有4种无序关联容器，它们是unordered set、unordered multiset、unordered map和 unordered multimap。 <mark>p707</mark></p>
</li>
</ul>
<h3 id="165-函数对象"><a class="markdownIt-Anchor" href="#165-函数对象"></a> 16.5 函数对象</h3>
<ul>
<li>
<p>很多STL 算法都使用函数对象，也叫函数符(functor)。函数符是可以以函数方式与()结合使用的任意对象。这包括函数名、指向函数的指针和重载了()运算符的**类对象(即定义了函数 <code>operator()()</code>的类)。**使用函数对象的方法就像在执行函数调用一样。比如：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TooBig</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T cutoff;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TooBig</span>(<span class="type">const</span> T &amp; t) : <span class="built_in">cutoff</span>(t) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T &amp; v)</span> </span>&#123; <span class="keyword">return</span> v &gt; cutoff; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">TooBig&lt;<span class="type">int</span>&gt; <span class="title">f100</span><span class="params">(<span class="number">100</span>)</span></span>;	<span class="comment">//cutoff = 100</span></span><br><span class="line"><span class="built_in">f100</span>(<span class="number">20</span>);				<span class="comment">//same as operator()(20)， return false</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>函数符的概念：</p>
<ul>
<li>生成器(generator)是不用参数就可以调用的函数符。</li>
<li>一元函数(unary function)是用一个参数可以调用的函数符。</li>
<li>二元函数(binary function)是用两个参数可以调用的函数符。例如，提供给 for_each()的函数符应当是一元函数，因为它每次用于一个容器元素</li>
<li>返回 bool 值的一元函数是谓词(predicate)，<strong>谓词在计算机语言中就是一个返回真假的表达式</strong></li>
<li>返回 bool 值的二元函数是二元谓词(binary predicate)。</li>
</ul>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这就是一个一元函数，只有一个参数，同时它的返回值是bool，所以是这是一个谓词</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T &amp; v)</span> </span>&#123; <span class="keyword">return</span> v &gt; cutoff; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*****************************使用示例***********************************/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123; cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>; &#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> vals[<span class="number">10</span>] = &#123;<span class="number">50</span>, <span class="number">100</span>, <span class="number">90</span>, <span class="number">180</span>, <span class="number">60</span>, <span class="number">210</span>, <span class="number">415</span>, <span class="number">88</span>, <span class="number">188</span>, <span class="number">201</span>&#125;;</span><br><span class="line">    <span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">datas</span><span class="params">(vals, vals + <span class="number">10</span>)</span></span>; <span class="comment">// 用迭代器做参数的构造函数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Original datas:\n&quot;</span>;</span><br><span class="line">    <span class="function">ostream_iterator&lt;<span class="type">int</span>&gt; <span class="title">out_itr</span><span class="params">(cout, <span class="string">&quot; &quot;</span>)</span></span>;	<span class="comment">//&quot; &quot;作为分隔符</span></span><br><span class="line">    <span class="built_in">copy</span>(datas.<span class="built_in">begin</span>(), datas.<span class="built_in">end</span>(), out_itr);	<span class="comment">//显示datas中的数据，每个数据之间插入空格</span></span><br><span class="line">    <span class="function">TooBig&lt;<span class="type">int</span>&gt; <span class="title">f100</span><span class="params">(<span class="number">100</span>)</span></span>;	<span class="comment">//设置限制为100</span></span><br><span class="line">    datas.<span class="built_in">remove_if</span>(f100);	<span class="comment">//remove_if方法需要传入一个谓词,f100对象中有一个谓词</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Removed datas:\n&quot;</span>;</span><br><span class="line">    for_each(atas.<span class="built_in">begin</span>(), datas.<span class="built_in">end</span>(), show);	<span class="comment">//显示每个数据，第三个参数是一元函数对象，也可以传入一元函数指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>自适应函数符：  <mark>p711</mark></p>
<ul>
<li>自适应生成器(adaptable generator)</li>
<li>自适应一元函数(adaptable unary function)</li>
<li>自适应二元函数(adaptable  binary function)</li>
<li>自适应谓词(adaptable  predicate)</li>
<li>自适应二元谓词(adaptable  binary  predicate)</li>
</ul>
</li>
<li>
<p>使函数符成为自适应的原因是，它携带了标识参数类型和返回类型的typedef 成员。这些成员分别是result_type、first_argument_type 和 second_argument_type，它们的作用是不言自明的。例如，<code>plus&lt;int&gt;</code>对象的返回类型被标识为<code>plus&lt;int&gt;::result_type</code>，这是int的typedef。</p>
</li>
<li>
<p>函数符自适应性的意义在于：函数适配器对象可以使用函数对象，并认为存在这些typedef成员。</p>
</li>
<li>
<p>C++11提供了函数指针和函数符的替代品：lambda表达式</p>
</li>
</ul>
<h3 id="166-算法"><a class="markdownIt-Anchor" href="#166-算法"></a> 16.6 算法</h3>
<ul>
<li>
<p>在头文件<code>&lt;algorithm&gt;</code>下，有一些STL预设的处理容器的非成员函数，例如<code>sort()</code>、<code>copy()</code>、<code>find()</code>、<code>random_shuffle()</code>、<code>set_union()</code>、<code>set intersection()</code>、<code>set_difference()</code>和 <code>transform()</code>等等。 <mark>p713</mark></p>
</li>
<li>
<p>因为<strong>指针是一种特殊的迭代器</strong>，因此诸如<code>copy()</code>等 STL 函数可用于常规数组。</p>
</li>
<li>
<p>可以使用<code>==</code>来比较不同类型的容器，如deque和vector，<strong>因为<code>==</code>运算符使用迭代器来比较内容</strong>，因此如果deque对象和vector对象的内容相同，并且排列顺序也相同，则它们是相等的。</p>
</li>
<li>
<p>STL将算法库分成4组，前三组在头文件<code>&lt;algorithm&gt;</code>下，最后一组在头文件<code>&lt;numeric&gt;</code>下    <mark>p713</mark></p>
<ul>
<li>非修改式序列操作：不修改容器内容，例如<code>find()</code>、<code>for_each()</code></li>
<li>修改式序列操作：修改容器内容，例如<code>transform()</code>、<code>copy()</code></li>
<li>排序和相关操作：包括多个排序函数(包括<code>sort()</code>)和其他各种函数，包括集合操作</li>
<li>通用数字运算：数字操作包括将区间的内容累积、计算两个容器的内部乘积、计算小计、计算相邻对象差的函数。通常，这些都是数组的操作特性，因此 vector 是最有可能使用这些操作的容器。</li>
</ul>
</li>
<li>
<p>对算法按照结果放置的位置进行分类： <mark>p714</mark></p>
<ul>
<li>在sort()函数完成时，结果被存放在原始数据的位置上，因此，sort()是就地算法(im-place algorithm)；</li>
<li>而copy()函数将结果发送到另一个位置，所以它是复制算法(copying algorithm)。</li>
<li>transform()函数可以以这两种方式完成工作。与copy()相似，它使用输出迭代器指示结果的存储位置；与copy()不同的是，transform()允许输出迭代器指向输入区间，因此它可以用计算结果覆盖原来的值。</li>
</ul>
</li>
<li>
<p>string类虽然不是STL的组成部分，但设计它时考虑到了STL。例如，它包含begin()、end()、rbegin()和rend()等成员，因此可以使用 STL接口。 <mark>p715</mark></p>
</li>
<li>
<p>有时可以选择使用 STL方法或 STL函数。通常方法是更好的选择。首先，它更适合于特定的容；其次，作为成员函数，它可以使用模板类的内存管理工具，从而在需要时调整容器的长度。  <mark>p716</mark></p>
</li>
</ul>
<h3 id="167-其他库"><a class="markdownIt-Anchor" href="#167-其他库"></a> 16.7 其他库</h3>
<ul>
<li>C++11提供的三个数组模板：<code>vector</code>、<code>valarray</code>和<code>array</code>的区别
<ul>
<li>vector 模板类是一个容器类和算法系统的一部分，它支持面向容器的操作，如排序、插入、重新排列、搜索、将数据转移到其他容器中等。</li>
<li>valarray 类模板是面向数值计算的，不是 STL的部分。例如，它没有 push_back()和 insert()方法，但为很多数学运算提供了一个简单、直观的接口。</li>
<li>array是为替代内置数组而设计的，它通过提供更好、更安全的接口，让数组更紧凑，效率更高。Array 表<br />
示长度固定的数组，因此不支持push back()和inser()，但提供了多个STL方法，包括 begin()、end()、<br />
rbegin()和 rend()，这使得很容易将 STL 算法用于array对象。</li>
</ul>
</li>
<li>模板<code>initializer_list</code>是C++11新增的。可以使用初始化列表语法将STL容器初始化为一系列值：<code>std::vector&lt;double&gt; payments &#123;45.99, 39.23, 19.95&#125;;</code>与<code>std::vector&lt;double&gt; payments (&#123;45.99, 39.23, 19.95&#125;);</code>等价。后面这种方式将<code>initializer_list&lt;double&gt;</code>作为构造函数的参数。</li>
<li><code>initializer_list</code>元素的类型都必须相同，编译器将进行必要的转换。  <mark>p725</mark></li>
</ul>
<h3 id="169-复习题"><a class="markdownIt-Anchor" href="#169-复习题"></a> 16.9 复习题</h3>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzI4ODc4ODM1MA==&amp;mid=2247484188&amp;idx=1&amp;sn=34e27b58eab6c0af56ebb284e0e6ad30&amp;chksm=ec38590ddb4fd01bba3358d734ada3aef9939213eab917547e6be0ff1b1483d57514c867c61f&amp;scene=178&amp;cur_album_id=1912546389490794501#rd">复习题</a></p>
<p><strong>1. 考虑下面的类声明：</strong></p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class RQ1</span><br><span class="line">&#123;</span><br><span class="line">  private:</span><br><span class="line">    char * st; // points to C-style string</span><br><span class="line">  public:</span><br><span class="line">    RQ1() &#123; st = new char [1]; strcpy(st,&quot;&quot;); &#125;</span><br><span class="line">    RQ1(const char * s)</span><br><span class="line">    &#123;st = new char [strlen(s) + 1]; strcpy(st, s); &#125;</span><br><span class="line">    RQ1(const RQ1 &amp; rq)</span><br><span class="line">    &#123;st = new char [strlen(rq.st) + 1]; strcpy(st, rq.st); &#125;</span><br><span class="line">    ~RQ1() &#123;delete [] st&#125;;</span><br><span class="line">    RQ &amp; operator=(const RQ &amp; rq);</span><br><span class="line">    // more stuff</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>将它转换为使用<code>string</code>对象的声明。哪些方法不再需要显式定义？</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RQ1</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    string st; </span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RQ1</span>():<span class="built_in">st</span>(<span class="string">&quot;&quot;</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">RQ1</span>(<span class="type">const</span> <span class="type">char</span> * s):<span class="built_in">st</span>(s)&#123;&#125;</span><br><span class="line">    ~<span class="built_in">RQ1</span>() &#123;&#125;;</span><br><span class="line">    <span class="comment">// more stuff</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>因为<code>string</code>对象提供了自己的内存管理功能，所以不需要再显式定义复制构造函数、析构程序和赋值运算符。</p>
<p><strong>2、在易于使用方面，指出string对象至少两个优于C-风格字符串的地方</strong></p>
<p>可以将一个 string 对象赋给另一个。sting 对象提供了自己的内存管理功能，所以一般不需要担心字符串超出存储容量。</p>
<p><strong>3、编写一个函数，用string对象作为参数，将string对象转换为全部大写</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">strToUpper</span><span class="params">(string &amp; st)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; st.<span class="built_in">size</span>(); i++)</span><br><span class="line">        st[i] = <span class="built_in">toupper</span>(st[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4、从概念上或语法上说，下面哪个不是正确使用 auto ptr 的方法(假设已经包含了所需的头文件)？</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">auto_ptr&lt;<span class="type">int</span>&gt;<span class="built_in">pia</span>(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">20</span>]);	<span class="comment">//错误，对于auto_ptr只能使用new，不能使用new[]</span></span><br><span class="line"><span class="built_in">auto_ptr</span>&lt;string&gt;(<span class="keyword">new</span> string);	<span class="comment">//错误，没有指针对象的名称</span></span><br><span class="line"><span class="type">int</span> rigue =<span class="number">7</span>;</span><br><span class="line">auto_ptr&lt;<span class="type">int</span>&gt;<span class="built_in">pr</span>(&amp;rique);		<span class="comment">//错误，没有使用new分配内存</span></span><br><span class="line"><span class="function">auto_ptr <span class="title">dbl</span><span class="params">(<span class="keyword">new</span> <span class="type">double</span>)</span></span>;		<span class="comment">//错误，缺少了&lt;double&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>5. 如果可以生成一个存储高尔夫球棍（而不是数字）的栈，为何它（从概念上说）是一个坏的高尔夫袋子？</strong></p>
<p>栈的后入先出（LIFO）的特性意味着在取出目标球棍，需要删除在目标球棍入袋（入栈）之后入袋的所有球棍。</p>
<p><strong>6. 为什么说对于逐洞记录高尔夫成绩来说，set容器是糟糕的选择？</strong></p>
<p>set集合只存储每个值的一个拷贝，即具备去重机制，因此多个相同得分会被存储为一个得分。</p>
<p><strong>7、既然指针是一个迭代器，为什么STL设计人员没有简单地使用指针来代替迭代器呢？</strong></p>
<p>使用迭代器使得能够使用接口类似于指针的对象遍历不以数组方式组织的数据，如双向链表中的数据。</p>
<p><strong>8、为什么 STL设计人员仅定义了迭代器基类，而使用继承来派生其他迭代器类型的类，并根据这些迭代器类来表示算法？</strong></p>
<p>STL方法使得可以将STL函数用于指向常规数组的常规指针以及指向STL容器类的迭代器，因此提高了通用性。</p>
<p><strong>9、给出<code>vector</code>对象比常规数组方便的3个例子。</strong></p>
<p>一个<code>vector</code>对象可以赋值给另外一个<code>vector</code>对象；<code>vector</code>可以自己管理自己的内存，自动调整长度；<code>vector</code>可以使用<code>at()</code>方法，可以自动检查边界。</p>
<p><strong>10. 如果程序清单16.9是使用<code>list</code>（而不是<code>vector</code>）实现的，则该程序的哪些部分将是非法的？非法部分能够轻松修复吗？如果可以，如何修复呢？</strong></p>
<p><code>list</code>不支持随机访问，因此公用<code>sort</code>方法无法使用，需要使用<code>list</code>自己的<code>sort</code>方法。<code>list</code>不支持随机打乱，可以将其放到<code>vector</code>，然后使用<code>vector</code>打乱，然后再转回<code>list</code>。</p>
<p><strong>11. 假设有程序清单16.15所示的函数符<code>TooBig</code>，下面的代码有何功能？赋给<code>bo</code>的是什么值？</strong></p>
<blockquote>
<p><code>bool bo = TooBig&lt;int&gt;(10)(15);</code></p>
</blockquote>
<p><code>TooBig</code>的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TooBig</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T cutoff;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TooBig</span>(<span class="type">const</span> T&amp; t):<span class="built_in">cutoff</span>(t)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; v)</span></span>&#123;<span class="keyword">return</span> v &gt; cutoff; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于<code>TooBig&lt;int&gt;(10)(15)</code>，<code>T</code>为<code>int</code>，10是用来初始化cutoff，15对应的是<code>operator()(const T&amp; v)</code>中的<code>v</code>，则<code>bo = TooBig&lt;int&gt;(10)(15) = 15 &gt; 10 = true</code>。</p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2024/08/08/%E7%AC%AC17%E7%AB%A0%E8%BE%93%E5%85%A5%E3%80%81%E8%BE%93%E5%87%BA%E5%92%8C%E6%96%87%E4%BB%B6/" rel="prev" title="C++ Primer Plus第17章学习笔记">
                  <i class="fa fa-angle-left"></i> C++ Primer Plus第17章学习笔记
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2024/08/11/STM32-RTC/" rel="next" title="STM32学习记录(九)：RTC">
                  STM32学习记录(九)：RTC <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Lyx</span>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/qianxiaohan" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  

  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.9.0/mermaid.min.js","integrity":"sha256-stuqcu2FrjYCXDOytWFA5SoUE/r3nkp6gTglzNSlavU="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>

  <script class="next-config" data-name="wavedrom" type="application/json">{"enable":true,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/wavedrom/3.5.0/wavedrom.min.js","integrity":"sha256-INLAoJc6quTNfiMWkGZniYO2cxE8mHpddnLow1m6RFs="}}</script>
  <script class="next-config" data-name="wavedrom_skin" type="application/json">{"enable":true,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/wavedrom/3.5.0/skins/default.js","integrity":"sha256-fduc/Zszk5ezWws2uInY/ALWVmIrmV6VTgXbsYSReFI="}}</script>
  <script src="/js/third-party/tags/wavedrom.js"></script>




  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css" integrity="sha256-UF1fgpAiu3tPJN/uCqEUHNe7pnr+QR0SQDNfgglgtcM=" crossorigin="anonymous">
  <script class="next-config" data-name="katex" type="application/json">{"copy_tex_js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/contrib/copy-tex.min.js","integrity":"sha256-Us54+rSGDSTvIhKKUs4kygE2ipA0RXpWWh0/zLqw3bs="}}</script>
  <script src="/js/third-party/math/katex.js"></script>



</body>
</html>
